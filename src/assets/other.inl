/* This file is autogenerated by tools/create_assets.py */

{
	.path = "data/other/povray_template.pov",
	.size = 748,
	.data = "// Generated from goxel {{version}}\n// https://github.com/guillaumechereau/goxel\n\n{{#camera}}\ncamera {\n    perspective\n    right x*{{width}}/{{height}}\n    direction <0, 0, -1>\n    angle {{angle}}\n    transform {\n        matrix {{modelview}}\n        inverse\n    }\n}\n{{/camera}}\n\n#declare Voxel = box {<-0.5, -0.5, -0.5>, <0.5, 0.5, 0.5>}\n#macro Vox(Pos, Color)\n    object {\n        Voxel\n        translate Pos\n        translate <0.5, 0.5, 0.5>\n        texture { pigment {color rgb Color / 255} }\n    }\n#end\n\n{{#light}}\nglobal_settings { ambient_light rgb<1, 1, 1> * {{ambient}} }\nlight_source {\n    <0, 0, 1024> color rgb <2, 2, 2>\n    parallel\n    point_at {{point_at}}\n}\n{{/light}}\n\nunion {\n{{#voxels}}\n    Vox({{pos}}, {{color}})\n{{/voxels}}\n}\n"
},

{
	.path = "data/other/vector3.lua",
	.size = 12524,
	.data = "--------------------------------------------------------------------------------\n--   Copyright (c) 2015 , 蒙占志(topameng) topameng@gmail.com\n--   All rights reserved.\n--\n--   Use, modification and distribution are subject to the \"New BSD License\"\n--   as listed at <url: http://www.opensource.org/licenses/bsd-license.php>.\n--------------------------------------------------------------------------------\n\nlocal acos	= math.acos\nlocal sqrt 	= math.sqrt\nlocal max 	= math.max\nlocal min 	= math.min\nlocal clamp = math.clamp\nlocal cos	= math.cos\nlocal sin	= math.sin\nlocal abs	= math.abs\nlocal sign	= math.sign\nlocal setmetatable = setmetatable\nlocal rawset = rawset\nlocal rawget = rawget\n\nlocal rad2Deg = math.rad2Deg\nlocal deg2Rad = math.deg2Rad\n\nVector3 = {	\n	class = \"Vector3\",\n}\n\nlocal fields = {}\n\nsetmetatable(Vector3, Vector3)\n\nVector3.__index = function(t,k)\n	local var = rawget(Vector3, k)\n	\n	if var == nil then							\n		var = rawget(fields, k)\n		\n		if var ~= nil then\n			return var(t)				\n		end		\n	end\n	\n	return var\nend\n\nVector3.__call = function(t,x,y,z)\n	return Vector3.New(x,y,z)\nend\n\nfunction Vector3.New(x, y, z)\n	local v = {x = x or 0, y = y or 0, z = z or 0}		\n	setmetatable(v, Vector3)		\n	return v\nend\n	\nfunction Vector3:Set(x,y,z)	\n	self.x = x or 0\n	self.y = y or 0\n	self.z = z or 0\nend\n\nfunction Vector3:Get()	\n	return self.x, self.y, self.z	\nend\n\nfunction Vector3:Clone()\n	return Vector3.New(self.x, self.y, self.z)\nend\n\nfunction Vector3.Distance(va, vb)\n	return sqrt((va.x - vb.x)^2 + (va.y - vb.y)^2 + (va.z - vb.z)^2)\nend\n\nfunction Vector3.Dot(lhs, rhs)\n	return (((lhs.x * rhs.x) + (lhs.y * rhs.y)) + (lhs.z * rhs.z))\nend\n\nfunction Vector3.Lerp(from, to, t)	\n	t = clamp(t, 0, 1)\n	return Vector3.New(from.x + ((to.x - from.x) * t), from.y + ((to.y - from.y) * t), from.z + ((to.z - from.z) * t))\nend\n\nfunction Vector3:Magnitude()\n	return sqrt(self.x * self.x + self.y * self.y + self.z * self.z)\nend\n\nfunction Vector3.Max(lhs, rhs)\n	return Vector3.New(max(lhs.x, rhs.x), max(lhs.y, rhs.y), max(lhs.z, rhs.z))\nend\n\nfunction Vector3.Min(lhs, rhs)\n	return Vector3.New(min(lhs.x, rhs.x), min(lhs.y, rhs.y), min(lhs.z, rhs.z))\nend\n\nfunction Vector3:Normalize()\n	local v = self:Clone()\n	return v:SetNormalize()\nend\n\nfunction Vector3:SetNormalize()\n	local num = self:Magnitude()	\n	\n	if num == 1 then\n		return self\n	elseif num > 1e-5 then    \n		self:Div(num)\n	else    \n		self:Set(0,0,0)\n	end \n\n	return self\nend\n	\nfunction Vector3:SqrMagnitude()\n	return self.x * self.x + self.y * self.y + self.z * self.z\nend\n\nlocal dot = Vector3.Dot\n\nfunction Vector3.Angle(from, to)\n	return acos(clamp(dot(from:Normalize(), to:Normalize()), -1, 1)) * rad2Deg\nend\n\nfunction Vector3:ClampMagnitude(maxLength)	\n	if self:SqrMagnitude() > (maxLength * maxLength) then    \n		self:SetNormalize()\n		self:Mul(maxLength)        \n	end\n	\n	return self\nend\n\n\nfunction Vector3.OrthoNormalize(va, vb, vc)	\n	va:SetNormalize()\n	vb:Sub(vb:Project(va))\n	vb:SetNormalize()\n	\n	if vc == nil then\n		return va, vb\n	end\n	\n	vc:Sub(vc:Project(va))\n	vc:Sub(vc:Project(vb))\n	vc:SetNormalize()		\n	return va, vb, vc\nend\n\nfunction Vector3.RotateTowards2(from, to, maxRadiansDelta, maxMagnitudeDelta)	\n	local v2 	= to:Clone()\n	local v1 	= from:Clone()\n	local len2 	= to:Magnitude()\n	local len1 	= from:Magnitude()	\n	v2:Div(len2)\n	v1:Div(len1)\n	\n	local dota	= dot(v1, v2)\n	local angle = acos(dota)			\n	local theta = min(angle, maxRadiansDelta)	\n	local len	= 0\n	\n	if len1 < len2 then\n		len = min(len2, len1 + maxMagnitudeDelta)\n	elseif len1 == len2 then\n		len = len1\n	else\n		len = max(len2, len1 - maxMagnitudeDelta)\n	end\n							\n	v2:Sub(v1 * dota)\n	v2:SetNormalize()     \n	v2:Mul(sin(theta))\n	v1:Mul(cos(theta))\n	v2:Add(v1)\n	v2:SetNormalize()\n	v2:Mul(len)\n	return v2	\nend\n\nfunction Vector3.RotateTowards1(from, to, maxRadiansDelta, maxMagnitudeDelta)	\n	local omega, sinom, scale0, scale1, len, theta\n	local v2 	= to:Clone()\n	local v1 	= from:Clone()\n	local len2 	= to:Magnitude()\n	local len1 	= from:Magnitude()	\n	v2:Div(len2)\n	v1:Div(len1)\n	\n	local cosom = dot(v1, v2)\n	\n	if len1 < len2 then\n		len = min(len2, len1 + maxMagnitudeDelta)	\n	elseif len1 == len2 then\n		len = len1\n	else\n		len = max(len2, len1 - maxMagnitudeDelta)\n	end 	\n	\n	if 1 - cosom > 1e-6 then	\n		omega 	= acos(cosom)\n		theta 	= min(omega, maxRadiansDelta)		\n		sinom 	= sin(omega)\n		scale0 	= sin(omega - theta) / sinom\n		scale1 	= sin(theta) / sinom\n		\n		v1:Mul(scale0)\n		v2:Mul(scale1)\n		v2:Add(v1)\n		v2:Mul(len)\n		return v2\n	else 		\n		v1:Mul(len)\n		return v1\n	end			\nend\n	\nfunction Vector3.MoveTowards(current, target, maxDistanceDelta)	\n	local delta = target - current	\n	local sqrDelta = delta:SqrMagnitude()\n	local sqrDistance = maxDistanceDelta * maxDistanceDelta\n	\n	if sqrDelta > sqrDistance then    \n		local magnitude = sqrt(sqrDelta)\n		\n		if magnitude > 1e-6 then\n			delta:Mul(maxDistanceDelta / magnitude)\n			delta:Add(current)\n			return delta\n		else\n			return current:Clone()\n		end\n	end\n	\n	return target:Clone()\nend\n\nfunction ClampedMove(lhs, rhs, clampedDelta)\n	local delta = rhs - lhs\n	\n	if delta > 0 then\n		return lhs + min(delta, clampedDelta)\n	else\n		return lhs - min(-delta, clampedDelta)\n	end\nend\n\nlocal overSqrt2 = 0.7071067811865475244008443621048490\n\nlocal function OrthoNormalVector(vec)\n	local res = Vector3.New()\n	\n	if abs(vec.z) > overSqrt2 then			\n		local a = vec.y * vec.y + vec.z * vec.z\n		local k = 1 / sqrt (a)\n		res.x = 0\n		res.y = -vec.z * k\n		res.z = vec.y * k\n	else			\n		local a = vec.x * vec.x + vec.y * vec.y\n		local k = 1 / sqrt (a)\n		res.x = -vec.y * k\n		res.y = vec.x * k\n		res.z = 0\n	end\n	\n	return res\nend\n\nfunction Vector3.RotateTowards(current, target, maxRadiansDelta, maxMagnitudeDelta)\n	local len1 = current:Magnitude()\n	local len2 = target:Magnitude()\n	\n	if len1 > 1e-6 and len2 > 1e-6 then	\n		local from = current / len1\n		local to = target / len2		\n		local cosom = dot(from, to)\n				\n		if cosom > 1 - 1e-6 then		\n			return Vector3.MoveTowards (current, target, maxMagnitudeDelta)		\n		elseif cosom < -1 + 1e-6 then		\n			local axis = OrthoNormalVector(from)						\n			local q = Quaternion.AngleAxis(maxRadiansDelta * rad2Deg, axis)	\n			local rotated = q:MulVec3(from)\n			local delta = ClampedMove(len1, len2, maxMagnitudeDelta)\n			rotated:Mul(delta)\n			return rotated\n		else		\n			local angle = acos(cosom)\n			local axis = Vector3.Cross(from, to)\n			axis:SetNormalize ()\n			local q = Quaternion.AngleAxis(min(maxRadiansDelta, angle) * rad2Deg, axis)			\n			local rotated = q:MulVec3(from)\n			local delta = ClampedMove(len1, len2, maxMagnitudeDelta)\n			rotated:Mul(delta)\n			return rotated\n		end\n	end\n		\n	return Vector3.MoveTowards(current, target, maxMagnitudeDelta)\nend\n	\nfunction Vector3.SmoothDamp(current, target, currentVelocity, smoothTime)\n	local maxSpeed = math.huge\n	local deltaTime = Time.deltaTime\n	smoothTime = max(0.0001, smoothTime)\n	local num = 2 / smoothTime\n	local num2 = num * deltaTime\n	local num3 = 1 / (((1 + num2) + ((0.48 * num2) * num2)) + (((0.235 * num2) * num2) * num2))    \n	local vector2 = target:Clone()\n	local maxLength = maxSpeed * smoothTime\n	local vector = current - target\n	vector:ClampMagnitude(maxLength)\n	target = current - vector\n	local vec3 = (currentVelocity + (vector * num)) * deltaTime\n	currentVelocity = (currentVelocity - (vec3 * num)) * num3\n	local vector4 = target + (vector + vec3) * num3	\n	\n	if Vector3.Dot(vector2 - current, vector4 - vector2) > 0 then    \n		vector4 = vector2\n		currentVelocity:Set(0,0,0)\n	end\n	\n	return vector4, currentVelocity\nend	\n	\nfunction Vector3.Scale(a, b)\n	local v = a:Clone()\n	return v:SetScale(b)\nend\n\nfunction Vector3:SetScale(b)\n	self.x = self.x * b.x\n	self.y = self.y * b.y\n	self.z = self.z * b.z	\n	return self\nend\n	\nfunction Vector3.Cross(lhs, rhs)\n	local x = lhs.y * rhs.z - lhs.z * rhs.y\n	local y = lhs.z * rhs.x - lhs.x * rhs.z\n	local z = lhs.x * rhs.y - lhs.y * rhs.x\n	return Vector3.New(x,y,z)	\nend\n	\nfunction Vector3:Equals(other)\n	return self.x == other.x and self.y == other.y and self.z == other.z\nend\n		\nfunction Vector3.Reflect(inDirection, inNormal)\n	local num = -2 * dot(inNormal, inDirection)\n	inNormal = inNormal * num\n	inNormal:Add(inDirection)\n	return inNormal\nend\n\n	\nfunction Vector3.Project(vector, onNormal)\n	local num = onNormal:SqrMagnitude()\n	\n	if num < 1.175494e-38 then	\n		return Vector3.New(0,0,0)\n	end\n	\n	local num2 = dot(vector, onNormal)\n	local v3 = onNormal:Clone()\n	v3:Mul(num2/num)	\n	return v3\nend\n	\nfunction Vector3.ProjectOnPlane(vector, planeNormal)\n	local v3 = Vector3.Project(vector, planeNormal)\n	v3:Mul(-1)\n	v3:Add(vector)\n	return v3\nend		\n\nfunction Vector3.Slerp2(from, to, t)		\n	if t <= 0 then\n		return from:Clone()\n	elseif t >= 1 then\n		return to:Clone()\n	end\n	\n	local v2 	= to:Clone()\n	local v1 	= from:Clone()\n	local len2 	= to:Magnitude()\n	local len1 	= from:Magnitude()	\n	v2:Div(len2)\n	v1:Div(len1)\n	\n	local omega = dot(v1, v2) 	\n	local len 	= (len2 - len1) * t + len1    		\n	local theta = acos(omega) * t\n	\n	v2:Sub(v1 * omega)\n	v2:SetNormalize()     \n	v2:Mul(sin(theta))\n	v1:Mul(cos(theta))\n	v2:Add(v1)\n	v2:SetNormalize()\n	v2:Mul(len)\n	return v2	\nend\n\nfunction Vector3.Slerp(from, to, t)\n	local omega, sinom, scale0, scale1\n\n	if t <= 0 then		\n		return from:Clone()\n	elseif t >= 1 then		\n		return to:Clone()\n	end\n	\n	local v2 	= to:Clone()\n	local v1 	= from:Clone()\n	local len2 	= to:Magnitude()\n	local len1 	= from:Magnitude()	\n	v2:Div(len2)\n	v1:Div(len1)\n\n	local len 	= (len2 - len1) * t + len1\n	local cosom = dot(v1, v2)\n	\n	if 1 - cosom > 1e-6 then\n		omega 	= acos(cosom)\n		sinom 	= sin(omega)\n		scale0 	= sin((1 - t) * omega) / sinom\n		scale1 	= sin(t * omega) / sinom\n	else \n		scale0 = 1 - t\n		scale1 = t\n	end\n\n	v1:Mul(scale0)\n	v2:Mul(scale1)\n	v2:Add(v1)\n	v2:Mul(len)\n	return v2\nend\n\n\nfunction Vector3:Mul(q)\n	if type(q) == \"number\" then\n		self.x = self.x * q\n		self.y = self.y * q\n		self.z = self.z * q\n	else\n		self:MulQuat(q)\n	end\n	\n	return self\nend\n\nfunction Vector3:Div(d)\n	self.x = self.x / d\n	self.y = self.y / d\n	self.z = self.z / d\n	\n	return self\nend\n\nfunction Vector3:Add(vb)\n	self.x = self.x + vb.x\n	self.y = self.y + vb.y\n	self.z = self.z + vb.z\n	\n	return self\nend\n\nfunction Vector3:Sub(vb)\n	self.x = self.x - vb.x\n	self.y = self.y - vb.y\n	self.z = self.z - vb.z\n	\n	return self\nend\n\nfunction Vector3:MulQuat(quat)	   \n	local num 	= quat.x * 2\n	local num2 	= quat.y * 2\n	local num3 	= quat.z * 2\n	local num4 	= quat.x * num\n	local num5 	= quat.y * num2\n	local num6 	= quat.z * num3\n	local num7 	= quat.x * num2\n	local num8 	= quat.x * num3\n	local num9 	= quat.y * num3\n	local num10 = quat.w * num\n	local num11 = quat.w * num2\n	local num12 = quat.w * num3\n	\n	local x = (((1 - (num5 + num6)) * self.x) + ((num7 - num12) * self.y)) + ((num8 + num11) * self.z)\n	local y = (((num7 + num12) * self.x) + ((1 - (num4 + num6)) * self.y)) + ((num9 - num10) * self.z)\n	local z = (((num8 - num11) * self.x) + ((num9 + num10) * self.y)) + ((1 - (num4 + num5)) * self.z)\n	\n	self:Set(x, y, z)	\n	return self\nend\n\nfunction Vector3.AngleAroundAxis (from, to, axis)	 	 \n	from = from - Vector3.Project(from, axis)\n	to = to - Vector3.Project(to, axis) 	    \n	local angle = Vector3.Angle (from, to)	   	    \n	return angle * (Vector3.Dot (axis, Vector3.Cross (from, to)) < 0 and -1 or 1)\nend\n\n\nVector3.__tostring = function(self)\n	return \"[\"..self.x..\",\"..self.y..\",\"..self.z..\"]\"\nend\n\nVector3.__div = function(va, d)\n	return Vector3.New(va.x / d, va.y / d, va.z / d)\nend\n\nVector3.__mul = function(va, d)\n	if type(d) == \"number\" then\n		return Vector3.New(va.x * d, va.y * d, va.z * d)\n	else\n		local vec = va:Clone()\n		vec:MulQuat(d)\n		return vec\n	end	\nend\n\nVector3.__add = function(va, vb)\n	return Vector3.New(va.x + vb.x, va.y + vb.y, va.z + vb.z)\nend\n\nVector3.__sub = function(va, vb)\n	return Vector3.New(va.x - vb.x, va.y - vb.y, va.z - vb.z)\nend\n\nVector3.__unm = function(va)\n	return Vector3.New(-va.x, -va.y, -va.z)\nend\n\nVector3.__eq = function(a,b)\n	local v = a - b\n	local delta = v:SqrMagnitude()\n	return delta < 1e-10\nend\n\n-- Direction                                     x  y  z\nfields.up 		= function() return Vector3.New( 0, 0, 1) end\nfields.down 	= function() return Vector3.New( 0, 0, 0) end\nfields.right	= function() return Vector3.New( 1, 0, 0) end\nfields.left		= function() return Vector3.New(-1, 0, 0) end\nfields.forward 	= function() return Vector3.New( 0, 1, 0) end\nfields.back		= function() return Vector3.New( 0,-1, 0) end\nfields.zero		= function() return Vector3.New( 0, 0, 0) end\n\nfields.magnitude 	= Vector3.Magnitude\nfields.normalized 	= Vector3.Normalize\nfields.sqrMagnitude = Vector3.SqrMagnitude\n"
},



